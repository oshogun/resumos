\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazilian]{babel}
\usepackage{comment} 

\setlength{\parindent}{4em}
\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.2}

\title{Resumo Prova 2 SO}
\author{Guilherme Christopher Michaelsen Cardoso \thanks{baseado no livrão do Tanenbaum}}
\date{\today}

\begin{document}
\begin{titlepage}
    \maketitle
\end{titlepage}
\section{Resum\~ao de SO (Prova 2)} 
\subsection{Espa\c{c}os de endere\c{c}amento}
\large{Expor mem\'oria f\'isica para processos tem diveras desvantagens:}
\begin{itemize}
    \item Permitir que programas de usu\'ario enderecem qualquer byte de mem\'oria
        torna poss\'ivel quebrar o sistema operacional.
    \item Com esse modelo, \'e dificil ter v\'arios programas rodando ao mesmo tempo.
\end{itemize}
\subsubsection{No\c{c}\~ao de espa\c{c}o de endere\c{c}amento}
\'E necess\'ario resolver dois problemas antes de permitir m\'ultiplas aplica\c{c}\~oes em 
mem\'oria ao mesmo tempo: prote\c{c}\~ao e relocação.

\begin{itemize}
    \item Espaço de Endereçamento:
        \begin{itemize}
            \item Conjunto de endereços que um processo pode usar para endereçar memória.
            \item Cada processo tem seu próprio espaço de endereçamento, independente dos outros
                processos (exceto em circunstâncias especiais onde processos querem compartilhar
                seus espaços de endereçamento).
        \end{itemize}
\end{itemize}
\subsection{Memória Virtual}
\begin{itemize}
    \item Enquanto a capacidade das memórias cresce rapidamente, o tamanho dos programas cresce 
        ainda mais rápido.
    \item Necessidade de rodar programas que são grandes demais para caber em memória
    \item Swapping não é uma alternativa desejável, devido à lentidão dos discos rígidos.
    \item \textbf{Memória virtual} foi a solução encontrada para esse problema.
        \begin{itemize}
            \item Cada programa tem seu pŕoprio espaço de endereçamento, que é dividido
                em partes chamadas \textbf{páginas}.
            \item Cada página é um intervalo contíguo de endereços, que são mapeados em
                memória física.
            \item Nem todas as páginas precisam estar em memória física ao mesmo tempo para 
                rodar o programa.
            \item Quando o programa referencia uma parte do endereço que já está
                em memória física, o hardware realiza o mapeamento necessário na hora.
            \item Quando o programa referencia uma parte do espaço de endereçamento 
                que não está em memória, o SO recebe um aviso para buscar a página
                faltante e reexecutar a instruçao que falhou.
            \item Funciona muito bem em sistemas multiprogramados com pedaços de vários
                programas na memória ao mesmo tempo. Quando um programa está esperando
                uma página ser buscada do disco, a CPU pode ser concedida a outro
                processo.
        \end{itemize}
\end{itemize}
\subsubsection{Paginação}
\begin{itemize}
    \item A maioria dos sistemas de memória virtual usam \textbf{paginação}
    \item Programas geram \textbf{endereços virtuais} de memória, formando o
        \textbf{espaço de endereçamento virtual}.
    \item Em sistemas com memória virtual, esses endereços não são enviados diretamente
        ao barramento da memória. Ao invés disso, vão para uma \textbf{MMU (Memory 
        Management Unit)}  que mapeia o endereço virtual em endereços de memória reais.
    \item O espaço de endereçamento virtual consiste de unidades de tamanho fixo chamadas
        \textbf{páginas}. AS unidades correspondentes em memória física são chamadas
        de \textbf{molduras de página}. As páginas e molduras de página geralmente
        tem o mesmo tamanho.
    \item Supondo um sistema de memória com páginas de 4KB, 64KB de espaço de 
        endereçamento virtual e 32KB de memória física, temos 16 páginas virtuais e
        8 molduras de páginas. 
    \item Sempre que se necessita buscar um item no disco, é necessário que a página
        inteira seja buscada.
    \item Vários processadores suportam múltiplos tamanhos de página que podem ser 
        misturados pelo SO de acordo com a necessidade.
        \begin{itemize}
            \item Ex.: A arquitetura x86\_64 suporta páginas de 4KB, 2MB e 1GB, sendo
                possível, por exemplo, utilizar páginas de 4KB para aplicações de
                usuário e uma única página de 1GB para o kernel do SO.
        \end{itemize}
    \item Exemplo: Supondo páginas de 4KB, 64KB de espaço de endereçamento virtual
        e 32KB de memória física. Um programa solicita um dado que está no endereço 
        virtual 0. Supondo que a página que contém os endereços 0 a 4095 está 
        mapeada na moldura de página numero 2. Qual o endereço de memória real que 
        será emitido pela MMU?
        \begin{itemize}
            \item A moldura 0 contém os endereços 0 a 4095. A moldura 1 contém os 
                endereços 4096 à 8191. Logo, a moldura 2 começa no endereço 
                8192 e vai até 12287. Portanto, o endereço físico que será
                emitido será 8192.
        \end{itemize}
    \item Exemplo 2: O endereço virtual 20500 é 20 bytes à partir do começo
        da página virtual 5 (endereços virtuais 20480 a 24575). Supondo que
        essa página seja mapeada para a moldura de página número 3 (12k-16k),
        o endereço físico emitido pela MMU será 12288 + 20 = 12308.
    \item Como existem mais páginas virtuais do que moldura física, é necessário
        controlar quais páginas virtuais estão presentes em memória física.
        Para isso, é usado um bit de controle (\textbf{bit presente/ausente}).
    \item Caso o programa referencie um endereço não mapeado, a MMU detecta isso
        e faz com que a CPU interrompa o sistema operacional. Essa interrupção
        é chamada de \textbf{page fault}. O SO então escolhe uma moldura de memória
        pouco usada, salva seu conteúdo no disco (caso já não esteja lá), e então
        busca (também do disco) a página que acabou de ser referenciada, colocando-a
        na moldura de página que foi liberada, refaz o mapeamento, e reinicia a 
        instrução interrompida.
    \item Exemplo: supondo um endereço virtual 8196 (0010000000000100 em binário),
        sendo mapeado pela MMU. Esse endereço virtual de 16 bits é dividido em
        duas partes: um número de página (4 bits) e um offset (12 bits). Com 4
        bits de offset, podemos endereçar \begin{math} 2^4 = 16\end{math} 
        páginas, e com um offset de 12 bits, podemos endereçar todos os 
        \begin{math}2^{12} = 4096 \end{math}bytes em uma página.
        \item O número da página é usado como índice na \textbf{tabela de páginas},
            representando o número da moldura de página correspondente àquela página
            virtual. Se o bit \textit{presente/ausente} é 0, uma interrupção ao SO
            é causada. Se é 1, o número da moldura de página encontrada na tabela
            de páginas é copiado para os 3 bits mais significativos do registrador
            destino, junto com o offset de 12 bits, que é copiado do endereço virtual.
            Juntos, eles formam um endereço físico de 15 bits. Esse endereço é então
            enviado ao barramento da memória como o endereço físico de memória. 
\end{itemize}
\subsubsection{Tabelas de página}
\par Em uma implementação simples, o mapeamento de endereços virtuais em endereços físicos 
pode ser feito da seguinte forma:
\begin{itemize}
    \item O endereço virtual é dividido em um número de página virtual (bits mais 
        significativos) e um offset (bits menos significativos)
        \begin{itemize}
            \item Por exemplo, em um endereço de 16 bits com páginas de 4KB,
                os 4 bits mais significativos especificam uma das 16 páginas virtuais
                e os 12 bits menos significativos representam o byte offset dentro
                da página selecionada.
            \item É possível usar endereços menores ou maiores para indexar a página,
                definindo tamanhos diferentes de páginas.
        \end{itemize}
    \item O número de página virtual é usado como índice na tabela de páginas para 
        encontrar a entrada para essa página virtual. A partir da entrada na tabela
        de páginas, o número da moldura de página (se existir), é encontrado.
    \item O número da moldura de página é concatenado aos bits mais significativos
    do offset, substituindo o número da página virtual, para formar um endereço
    físico que pode ser enviado para a memória.
\end{itemize}
\par Portanto, o propósito da tabela de páginas é mapear páginas virutais em molduras
de página. 

\subsubsection{Estrutura de uma entrada na tabela de páginas}

\par 
\indent O layout exato de uma entrada na tabela de páginas é altamente dependente da
máquina, mas a informaçao presente normalmente é a mesma.

\begin{itemize}
    \item O tamanho varia de computador a computador, mas 32 bits é um tamanho comum.
    \item O campo mais importante é o o \textit{número da moldura de página}.
    \item Em seguida, existe o bit \textit{presente/ausente}. Se esse bit for
        1, a entrada é válida e pode ser usada, caso contrário, a página virtual
        não está atualmente em memória. Acessar uma entrada na tabela de páginas
        que tenha esse bit em 0 causa um page fault.
    \item Os bits de proteção dizem quais tipos de acesso são permitidos. Na forma
        mais simples, se tem apenas um bit, que permite apenas leitura se estiver em
        0, e leitura ou escrita se estiver em 1. Uma alternativa é usar 3 bits,
        um para leitura, um para escrita e um para execução.
    \item Os bits \textit{modificado} e \textit{referenciado} controlam a utilização
        da página. Quando ocorre uma escrita em uma página, o hardware seta o bit
        \textit{modificado}. Esse bit é importante quando o SO decide usar aquela
        moldura de página. Se a página tiver sido modificada (suja), ela deve ser
        escrita novamente no disco. Se não, ela pode ser abandonada, já que a cópia
        em disco ainda é válida. Esse bit normalmente é chamado de \textbf{dirty bit}.
    \item O bit \textit{referenciado} é setado toda vez que uma página for referenciada,
        tanto para leitura quanto para escrita. Seu valor é usado para ajudar o SO a 
        escolher uma página quando ocorre um page fault. Páginas que não estão sendo
        usadas são melhores candidatas a serem substituídas.
    \item O último bit permite desabilitar o caching na página. Isso é importante para
        páginas que mapeiam direto em registradores de dispositivos ao invés de memória. 
        Se o sistema operacional estiver em loop esperando um dispositivo de I/O responder
        um comando, ele precisa buscar constantemente a word do dispositivo, e não usar
        uma cópia em cache desatualizada. Máquinas que não utilizam I/O mapeado em 
        memória não precisam deste bit.
\end{itemize}

\subsection{Acelerando a Paginação}
\par \indent Em qualquer sistema de paginação, dois problemas devem ser enfrentados:
\begin{enumerate}
    \item O mapeamento do endereço virtual para o endereço físico deve ser rápido.
    \item Se o endereço virtual for grande, a tabela de páginas também será.
\end{enumerate}
\par O primeiro problema ocorre devido à natureza dos programas. A cada instrução
executada, é necessário fazer mapeamento de endereços virtuais para físicos, já
que todas as instruções são buscadas em memória e muitas delas também referenciam
operandos em memória.
\par O segundo problema ocorre porque todos so computadores modernos utilizam 
endereços virtuais de 32 ou 64 bits. Usando páginas de  4KB, um endereço de 32 bits
é capaz de referenciar 1 milhão de páginas, e um endereço de 64 bits referencia um 
número absurdamente grande de páginas. Com 1 milhão de páginas no espaço de endereçamento
virtual, a tabela de páginas deve ter 1 milhão de entradas, e cada processo precisa
da sua própria tabela de páginas (por possuir seu próprio espaço de endereçamento).

\subsubsection{Translation Lookaside Buffers (TLB)}
\par \indent A maioria das técnicas de otimização de paginamento parte do princípio que
a tabela de páginas está em memória. Se uma instrução copia um registrador para outro,
por exemplo, em um sistema sem paginação, ela faz apenas uma referência à memória 
(para buscar a instrução em si). Com paginamento, pelo menos uma referência a mais
é necessária, para acessar a tabela de páginas. Devido ao impacto dos acessos de 
memória na performance da CPU, dobrar o número de acessos à memória diminui potencialmente
pela metade o desempenho.
    \par
\indent Baseado na observação de que a maioria dos programas tende a fazer um grande 
número de referências a um número pequeno de páginas, foi-se possível desenvolver uma 
solução para esse problema.
\begin{itemize}
    \item Essa solução consiste em equipar computadores com um componente em hardware
        que é capaz de mapear endereços virtuais em endereços físicos sem precisar
        acessar a tabela de páginas. Esse dispositivo é chamado de \textbf{TLB} 
        (Translation Lookaside Buffer).
    \item Esse dispositivo normalmente faz parte da MMU e consiste de uma tabela
        com um pequeno número de entradas, por exemplo, 8 (raramente mais do que 
        256). Cada entrada contém informação sobre uma página, incluindo o número
        da página virtual, um bit que indica se a página foi modificada, o código
        de proteção (permissões read/write/execute), e o número da moldura de página
        física na qual a página está localizada. Esses campos possuem correspondência
        1 para 1 com os campos na tabela de páginas, exceto pelo número da página virtual,
        que não é usado pela tabela de páginas. Outro bit indica se a entrada é válida
        ou não.
    \item Quando um endereço virtual é enviado à MMU para tradução, o hardware primeiro
        checa para ver se é um número de página virtual presente na TLB comparando 
        esse endereço paralelamente com todas as entradas na TLB. Se um cnadidato válido
        é encontrado e o acesso não viola os bits de proteção, a moldura de página é
        buscada diretamente do TLB, sem necessitar acessar a tabela de páginas.
    \item Se o número de página virtual está presente na TLB, mas a instrução está
        tentando escrever em uma página protegida contra escrita, uma protection 
        fault é gerada.
    \item Quando um número de página virtual não está no TLB, a MMU detecta o miss 
        e faz uma busca na tabela de páginas. Ela então remove uma das entradas
        do TLB e substitui com a entrada na tabela de páginas que acabou de encontrar.
        Se essa página for usada novamente em breve, ela será encontrada no TLB. 
    \item Quando uma entrada é removida do TLB, o bit de modificado é copiado de volta
        para a entrada da tabela de páginas em memória. Os outros valores já estão lá,
        exceto o bit de referência. Quando o TLB é carregado da tabela de páginas, todos
        os campos são buscados em memória.
\end{itemize}

\subsubsection{Gerenciamento de TLB por software}


\end{document}
